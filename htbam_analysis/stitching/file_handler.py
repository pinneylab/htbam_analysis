# TODO this looks like it should just be a utils type file with functions and no class
import pathlib
import re
from datetime import datetime
from copy import deepcopy
import pandas as pd
from htbam.image.stitching.rastering import raster


def get_time(path_name):
    chip_acq_time = re.match("^\d{8}_\d{6}|^\d{8}-\d{6}", path_name)
    acqui_time = datetime.strptime(chip_acq_time[0], "%Y%m%d-%H%M%S")
    return acqui_time


def parse_kinetic_folder(param_template, path):
    """
    I-Python Specific: Parses a folder containing time-series imaging

    Arguments:
        (RasterParams) param_template: a template RasterParams object
        (str) path: root path containg kinetic imaging folders

    Returns:
        (KineticImaging) A KineticImaging object of timecourse imaging

    """
    root = pathlib.Path(path)
    sub_folders = [
        i
        for i in root.iterdir()
        if ("StitchedImages" not in i.name) and (str(i.parts[-1])[0] != ".")
    ]

    get_raster_folders = lambda f: (f, get_time(f.name), _parse_folder(f))
    raster_folders = [get_raster_folders(f) for f in sub_folders]
    rasters = set
    for sub_folder, time, image_set in raster_folders:
        pt = deepcopy(param_template)
        pt.update_group_feature(time)
        pt.update_root(sub_folder)
        dims, exposuresImages = _read_images(
            image_set, "paths"
        )  # Grab the raster dimensions
        rasters = rasters.union(_make_rasters(pt, exposuresImages, dims).rasters)
    return raster.KineticImaging(path, rasters)


def parse_single_channel_folder(param_template, path) -> raster.RasterSet:
    """
    I-Python Specific: Parses a folder containing a single channel of rastered images
    (can contain multiple exposure times) and generates a set of rasters (a RasterSet)
    ready to stitch and export.

    Arguments:
        (RasterParams) param_template: a template RasterParams object
        (str) path: root path containing images

    Returns:
        (RasterSet) A RasterSet containing a bag of Rasters

    """

    image_set = _parse_folder(path)
    dims, exposure_img_dict = _read_images(image_set, "paths")
    return _make_rasters(param_template, exposure_img_dict, dims)


def _parse_folder(path) -> pd.DataFrame:
    """
    I-Python Specific: Parses a folder containing a single channel of rastered images
    (can contain multiple exposure times) and generates a DataFrame of indexed
    tile paths. For using in Raster generation.

    Arguments:
        (str) path: root path containing images

    Returns:
        (pd.DataFrame) A DataFrame of indexed tiled image paths

    """
    root = pathlib.Path(path)
    paths = [pathlib.Path(i) for i in root.iterdir()]

    # D. Muir, adding to ignore hidden files
    paths = [path for path in paths if str(path.parts[-1])[0] != "."]
    file_names = [path.parts[-1] for path in paths]

    image_df = pd.DataFrame({"paths": paths, "files": file_names})

    def index_files(f):
        match = "\d{3}_\d{3}_\d{1,4}"
        return tuple(re.search(match, f)[0].split("_"))

    image_df["indexes"] = image_df.files.apply(index_files)

    # TODO This looks strange...
    image_df["x"] = image_df.indexes.apply(lambda i: int(i[0]))
    image_df["y"] = image_df.indexes.apply(lambda i: int(i[1]))
    image_df["exp"] = image_df.indexes.apply(lambda i: int(i[2]))
    return image_df.sort_values(["x", "y"]).reset_index(drop=True).set_index("exp")


def _make_rasters(param_template, exposure_images, dims):
    """
    I-Python Specific: Generates a RasterSet from a DataFrame of indexed rastered image paths.

    Arguments:
        (RasterParams) param_template: a template RasterParams object
        (dict) exposure_images: a dictionary of exposure:list of rastered images
        (tuple) dims: raster tiling dimensions (not image dimensions)

    Returns:
        (RasterSet) A collection of Rasters

    """
    rasters = []
    for exp, images in exposure_images.items():
        pc = deepcopy(param_template)

        pc.update_exposure(exp)
        pc.update_dims(dims)
        rasters.append(raster.FlatRaster(images, pc))
    return raster.RasterSet(set(rasters))


def _read_images(df, feature):
    """
    I-Python Specific: Extracts a raster worth of image path, in proper raster order, from a folder
    record generated by _parse_folder

    Arguments:
        (pd.DataFrame) df: DataFrame containing indexed tile paths
        (str) feature: name of DataFrame column containing path (typ. 'paths')

    Returns:
        (tuple) A tuple of raster tiling dimensions and ordered rastered image paths


    """
    # readImage = lambda i: io.imread(i)

    # Each folder can have multiple exposure times, but one channel
    exposures = set(df.index)
    image_refs = {}
    for exp in exposures:
        working_raster = df.loc[exp]
        xdims = working_raster["x"].drop_duplicates().size
        ydims = working_raster["y"].drop_duplicates().size
        dims = (xdims, ydims)
        image_refs[exp] = [i for i in working_raster[feature].tolist()]

    return dims, image_refs  # exposure time: list of image paths
